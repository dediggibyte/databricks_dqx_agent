name: "Deploy Databricks Asset Bundle"
description: "Validate and deploy the Databricks bundle for a target environment"
inputs:
  env:
    description: "Environment key (databricks bundle target)"
    required: true
  profile:
    description: "Databricks CLI profile to use"
    required: true
  lakebase-host:
    description: "Lakebase PostgreSQL host"
    required: false
    default: ""
  lakebase-database:
    description: "Lakebase database name"
    required: false
    default: "databricks_postgres"
  model-serving-endpoint:
    description: "Model serving endpoint for AI analysis"
    required: false
    default: "databricks-claude-sonnet-4-5"
  source-catalogs:
    description: "Comma-separated list of catalogs to grant app access to"
    required: false
    default: ""
  warehouse-id:
    description: "SQL Warehouse ID for executing Unity Catalog grants"
    required: false
    default: ""
runs:
  using: "composite"
  steps:
    - name: Validate bundle
      shell: bash
      run: |
        set -euxo pipefail
        databricks bundle validate -t "${{ inputs.env }}"

    - name: Deploy bundle (first pass - creates jobs)
      shell: bash
      run: |
        set -euxo pipefail
        databricks bundle deploy -t "${{ inputs.env }}"

    - name: Configure app.yaml with job IDs and secrets
      shell: bash
      env:
        LAKEBASE_HOST_VALUE: ${{ inputs.lakebase-host }}
        LAKEBASE_DATABASE_VALUE: ${{ inputs.lakebase-database }}
        MODEL_SERVING_ENDPOINT_VALUE: ${{ inputs.model-serving-endpoint }}
      run: |
        set -euo pipefail

        # Get job IDs from deployed bundle
        echo "Getting job IDs from bundle summary..."
        BUNDLE_SUMMARY=$(databricks bundle summary -t "${{ inputs.env }}" --output json)

        GENERATION_JOB_ID=$(echo "$BUNDLE_SUMMARY" | jq -r '.resources.jobs.dq_rule_generation.id // empty')
        VALIDATION_JOB_ID=$(echo "$BUNDLE_SUMMARY" | jq -r '.resources.jobs.dq_rule_validation.id // empty')

        echo "Generation Job ID: $GENERATION_JOB_ID"
        echo "Validation Job ID: $VALIDATION_JOB_ID"

        # Regenerate src/app.yaml with proper structure
        printf '%s\n' \
          'command:' \
          '  - gunicorn' \
          '  - --bind' \
          '  - 0.0.0.0:8000' \
          '  - --workers' \
          '  - "2"' \
          '  - --timeout' \
          '  - "300"' \
          '  - wsgi:app' \
          '' \
          'env:' > src/app.yaml

        # Add job IDs
        if [ -n "$GENERATION_JOB_ID" ]; then
          echo "  - name: DQ_GENERATION_JOB_ID" >> src/app.yaml
          echo "    value: \"$GENERATION_JOB_ID\"" >> src/app.yaml
        fi

        if [ -n "$VALIDATION_JOB_ID" ]; then
          echo "  - name: DQ_VALIDATION_JOB_ID" >> src/app.yaml
          echo "    value: \"$VALIDATION_JOB_ID\"" >> src/app.yaml
        fi

        # Add Lakebase config if provided
        if [ -n "$LAKEBASE_HOST_VALUE" ]; then
          echo "  - name: LAKEBASE_HOST" >> src/app.yaml
          echo "    value: \"$LAKEBASE_HOST_VALUE\"" >> src/app.yaml
        fi

        if [ -n "$LAKEBASE_DATABASE_VALUE" ]; then
          echo "  - name: LAKEBASE_DATABASE" >> src/app.yaml
          echo "    value: \"$LAKEBASE_DATABASE_VALUE\"" >> src/app.yaml
        fi

        # Add Model Serving Endpoint
        if [ -n "$MODEL_SERVING_ENDPOINT_VALUE" ]; then
          echo "  - name: MODEL_SERVING_ENDPOINT" >> src/app.yaml
          echo "    value: \"$MODEL_SERVING_ENDPOINT_VALUE\"" >> src/app.yaml
        fi

        echo "src/app.yaml configured:"
        cat src/app.yaml

    - name: Deploy bundle (second pass - updates app with config)
      shell: bash
      run: |
        set -euxo pipefail
        databricks bundle deploy -t "${{ inputs.env }}"

    - name: Grant job permissions to app service principal
      shell: bash
      run: |
        set -euo pipefail

        # Get bundle summary for job IDs and app name
        BUNDLE_SUMMARY=$(databricks bundle summary -t "${{ inputs.env }}" --output json)

        APP_NAME=$(echo "$BUNDLE_SUMMARY" | jq -r '.resources.apps.dqx_app.name // empty')
        GENERATION_JOB_ID=$(echo "$BUNDLE_SUMMARY" | jq -r '.resources.jobs.dq_rule_generation.id // empty')
        VALIDATION_JOB_ID=$(echo "$BUNDLE_SUMMARY" | jq -r '.resources.jobs.dq_rule_validation.id // empty')

        if [ -z "$APP_NAME" ]; then
          echo "Warning: Could not get app name from bundle"
          exit 0
        fi

        echo "Getting service principal for app: $APP_NAME"

        # Get app details to find the service principal
        APP_DETAILS=$(databricks apps get "$APP_NAME" --output json 2>/dev/null || echo "{}")
        APP_SP=$(echo "$APP_DETAILS" | jq -r '.service_principal_name // .effective_service_principal_name // empty')

        if [ -z "$APP_SP" ]; then
          echo "Warning: Could not get app service principal name"
          echo "App details: $APP_DETAILS"
          exit 0
        fi

        echo "Granting job permissions to app service principal: $APP_SP"

        # Grant CAN_MANAGE_RUN on generation job
        if [ -n "$GENERATION_JOB_ID" ]; then
          echo "Granting CAN_MANAGE_RUN on generation job ($GENERATION_JOB_ID)..."
          databricks permissions update jobs "$GENERATION_JOB_ID" \
            --json "{\"access_control_list\": [{\"service_principal_name\": \"$APP_SP\", \"permission_level\": \"CAN_MANAGE_RUN\"}]}" \
            || echo "Warning: Failed to grant permissions on generation job"
        fi

        # Grant CAN_MANAGE_RUN on validation job
        if [ -n "$VALIDATION_JOB_ID" ]; then
          echo "Granting CAN_MANAGE_RUN on validation job ($VALIDATION_JOB_ID)..."
          databricks permissions update jobs "$VALIDATION_JOB_ID" \
            --json "{\"access_control_list\": [{\"service_principal_name\": \"$APP_SP\", \"permission_level\": \"CAN_MANAGE_RUN\"}]}" \
            || echo "Warning: Failed to grant permissions on validation job"
        fi

        echo "Job permissions granted successfully"

    - name: Grant Unity Catalog permissions to app
      if: ${{ inputs.source-catalogs != '' }}
      shell: bash
      env:
        WAREHOUSE_ID: ${{ inputs.warehouse-id }}
      run: |
        set -euo pipefail

        # Get app name from bundle summary
        BUNDLE_SUMMARY=$(databricks bundle summary -t "${{ inputs.env }}" --output json)
        APP_NAME=$(echo "$BUNDLE_SUMMARY" | jq -r '.resources.apps.dqx_app.name // empty')

        if [ -z "$APP_NAME" ]; then
          echo "Warning: Could not get app name from bundle"
          exit 0
        fi

        echo "Getting service principal for app: $APP_NAME"

        # Get app details to find the service principal
        APP_DETAILS=$(databricks apps get "$APP_NAME" --output json 2>/dev/null || echo "{}")
        APP_SP=$(echo "$APP_DETAILS" | jq -r '.service_principal_name // .effective_service_principal_name // empty')

        if [ -z "$APP_SP" ]; then
          echo "Warning: Could not get app service principal name"
          echo "App details: $APP_DETAILS"
          exit 0
        fi

        # Check if warehouse ID is provided
        if [ -z "$WAREHOUSE_ID" ]; then
          echo "Warning: No SQL warehouse ID provided. Skipping Unity Catalog grants."
          echo "Set the WAREHOUSE_ID secret to enable catalog permission grants."
          exit 0
        fi

        echo "Granting catalog access to app service principal: $APP_SP"

        # Function to execute SQL statement
        execute_sql() {
          local sql="$1"
          echo "Executing: $sql"
          databricks api post /api/2.0/sql/statements \
            --json "{\"warehouse_id\": \"$WAREHOUSE_ID\", \"statement\": \"$sql\", \"wait_timeout\": \"30s\"}" \
            2>/dev/null || return 1
        }

        # Parse comma-separated catalogs and grant access to each
        IFS=',' read -ra CATALOGS <<< "${{ inputs.source-catalogs }}"
        for catalog in "${CATALOGS[@]}"; do
          # Trim whitespace
          catalog=$(echo "$catalog" | xargs)
          if [ -n "$catalog" ]; then
            echo "Granting access to catalog: $catalog"

            # Grant USE CATALOG, USE SCHEMA on all schemas, and SELECT on all tables
            execute_sql "GRANT USE CATALOG ON CATALOG \`$catalog\` TO \`$APP_SP\`" || echo "Warning: Failed to grant USE CATALOG on $catalog"
            execute_sql "GRANT USE SCHEMA ON CATALOG \`$catalog\` TO \`$APP_SP\`" || echo "Warning: Failed to grant USE SCHEMA on $catalog"
            execute_sql "GRANT SELECT ON CATALOG \`$catalog\` TO \`$APP_SP\`" || echo "Warning: Failed to grant SELECT on $catalog"

            echo "Granted access to catalog: $catalog"
          fi
        done

        echo "Unity Catalog permissions granted successfully"

    - name: Run app (deploy and start)
      shell: bash
      run: |
        set -euxo pipefail
        echo "Starting app deployment via bundle run..."
        databricks bundle run dqx_app -t "${{ inputs.env }}"
        echo "App deployment initiated successfully"
