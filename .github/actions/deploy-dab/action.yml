name: "Deploy Databricks Asset Bundle"
description: "Validate and deploy the Databricks bundle for a target environment"
inputs:
  env:
    description: "Environment key (databricks bundle target)"
    required: true
  profile:
    description: "Databricks CLI profile to use"
    required: true
  lakebase-host:
    description: "Lakebase PostgreSQL host for storing DQ rules"
    required: false
    default: ""
runs:
  using: "composite"
  steps:
    - name: Validate bundle
      shell: bash
      run: |
        set -euxo pipefail
        databricks bundle validate -t "${{ inputs.env }}"

    - name: Configure app.yaml with secrets
      shell: bash
      run: |
        set -euo pipefail
        # Substitute environment-specific values in app.yaml
        if [ -n "${{ inputs.lakebase-host }}" ]; then
          echo "Configuring LAKEBASE_HOST..."
          sed -i 's|\${LAKEBASE_HOST}|${{ inputs.lakebase-host }}|g' app.yaml
        fi
        echo "app.yaml configured"

    - name: Deploy bundle
      shell: bash
      run: |
        set -euxo pipefail
        databricks bundle deploy -t "${{ inputs.env }}"

    - name: Deploy app
      shell: bash
      run: |
        set -euxo pipefail
        # Get app name based on environment
        case "${{ inputs.env }}" in
          dev)   APP_NAME="dqx-rule-generator-dev" ;;
          stage) APP_NAME="dqx-rule-generator-stage" ;;
          prod)  APP_NAME="dqx-rule-generator-prod" ;;
          *)     echo "Unknown environment: ${{ inputs.env }}"; exit 1 ;;
        esac

        # Get the workspace path where bundle files were deployed
        # Format: /Workspace/Users/<user>/.bundle/<bundle-name>/<target>/files
        WORKSPACE_PATH=$(databricks bundle summary -t "${{ inputs.env }}" --output json | jq -r '.workspace.file_path')

        echo "Deploying app: $APP_NAME"
        echo "Source code path: $WORKSPACE_PATH"

        # Deploy the app with the workspace source code path
        databricks apps deploy "$APP_NAME" --source-code-path "$WORKSPACE_PATH"
