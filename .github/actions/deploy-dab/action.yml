name: "Deploy Databricks Asset Bundle"
description: "Validate and deploy the Databricks bundle for a target environment"
inputs:
  env:
    description: "Environment key (databricks bundle target)"
    required: true
  profile:
    description: "Databricks CLI profile to use"
    required: true
  lakebase-host:
    description: "Lakebase PostgreSQL host for storing DQ rules"
    required: false
    default: ""
runs:
  using: "composite"
  steps:
    - name: Validate bundle
      shell: bash
      run: |
        set -euxo pipefail
        databricks bundle validate -t "${{ inputs.env }}"

    - name: Configure app.yaml with secrets
      shell: bash
      run: |
        set -euo pipefail
        # Substitute environment-specific values in app.yaml
        if [ -n "${{ inputs.lakebase-host }}" ]; then
          echo "Configuring LAKEBASE_HOST..."
          sed -i 's|\${LAKEBASE_HOST}|${{ inputs.lakebase-host }}|g' app.yaml
        fi
        echo "app.yaml configured"

    - name: Deploy bundle
      shell: bash
      run: |
        set -euxo pipefail
        databricks bundle deploy -t "${{ inputs.env }}"

    - name: Deploy app
      shell: bash
      run: |
        set -euo pipefail
        # Get app name based on environment
        case "${{ inputs.env }}" in
          dev)   APP_NAME="dqx-rule-generator-dev" ;;
          stage) APP_NAME="dqx-rule-generator-stage" ;;
          prod)  APP_NAME="dqx-rule-generator-prod" ;;
          *)     echo "Unknown environment: ${{ inputs.env }}"; exit 1 ;;
        esac

        # Get the workspace path where bundle files were deployed
        WORKSPACE_PATH=$(databricks bundle summary -t "${{ inputs.env }}" --output json | jq -r '.workspace.file_path')

        echo "Deploying app: $APP_NAME"
        echo "Source code path: $WORKSPACE_PATH"

        # Check current app status and wait for any active deployment
        echo "Checking app status..."
        MAX_WAIT=300  # 5 minutes max wait
        WAIT_TIME=0
        SLEEP_INTERVAL=15

        while [ $WAIT_TIME -lt $MAX_WAIT ]; do
          APP_STATUS=$(databricks apps get "$APP_NAME" --output json 2>/dev/null | jq -r '.active_deployment.status.state // .status.state // "UNKNOWN"' || echo "NOT_FOUND")
          echo "Current app status: $APP_STATUS"

          case "$APP_STATUS" in
            "RUNNING"|"SUCCEEDED"|"STOPPED"|"FAILED"|"NOT_FOUND"|"UNKNOWN"|"IDLE")
              echo "App is ready for deployment"
              break
              ;;
            "PENDING"|"IN_PROGRESS"|"DEPLOYING")
              echo "Deployment in progress, waiting ${SLEEP_INTERVAL}s..."
              sleep $SLEEP_INTERVAL
              WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
              ;;
            *)
              echo "Unknown status: $APP_STATUS, proceeding with deployment"
              break
              ;;
          esac
        done

        if [ $WAIT_TIME -ge $MAX_WAIT ]; then
          echo "Warning: Timed out waiting for active deployment. Proceeding anyway..."
        fi

        # Deploy the app with the workspace source code path
        echo "Starting app deployment..."
        databricks apps deploy "$APP_NAME" --source-code-path "$WORKSPACE_PATH" || {
          echo "Deploy command failed, checking if app is already running..."
          APP_STATE=$(databricks apps get "$APP_NAME" --output json 2>/dev/null | jq -r '.status.state // "UNKNOWN"')
          if [ "$APP_STATE" = "RUNNING" ]; then
            echo "App is already running, deployment successful via bundle deploy"
            exit 0
          else
            echo "App state: $APP_STATE"
            exit 1
          fi
        }

        echo "App deployment initiated successfully"
